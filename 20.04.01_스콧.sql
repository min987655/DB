SELECT *
FROM emp;

-- LAG() 함수 기본
SELECT ENAME, SAL, LAG(SAL, 1, 0) OVER(ORDER BY SAL DESC)
FROM EMP;

-- LAG() 함수 활용
SELECT ENAME, S1, S2, DECODE (S1, S2, NO-1, NO)
FROM (
SELECT ENAME, SAL "S1", LAG(SAL, 1, 0) OVER(ORDER BY SAL DESC) "S2", ROWNUM "NO"
FROM
(
SELECT ENAME, SAL
FROM emp
ORDER BY SAL DESC
));
-- RANK() OVER() 함수 : 위와 동일한 결과
SELECT ENAME, SAL, RANK() OVER (ORDER BY SAL DESC)
FROM EMP;

SELECT NAME, HEIGHT, RANK() OVER (ORDER BY HEIGHT DESC) 
FROM STUDENT;
--학년별 키 순위를 구하시오.
SELECT *
FROM STUDENT;

SELECT NAME, GRADE, HEIGHT, NO
FROM
(
SELECT NAME, GRADE, HEIGHT, RANK() OVER (ORDER BY HEIGHT DESC) "NO"
FROM STUDENT
WHERE GRADE = 1
)
UNION ALL
SELECT NAME, GRADE, HEIGHT, NO
FROM
(
SELECT NAME, GRADE, HEIGHT, RANK() OVER (ORDER BY HEIGHT DESC) "NO"
FROM STUDENT
WHERE GRADE = 2
)
UNION ALL
SELECT NAME, GRADE, HEIGHT, NO
FROM
(
SELECT NAME, GRADE, HEIGHT, RANK() OVER (ORDER BY HEIGHT DESC) "NO"
FROM STUDENT
WHERE GRADE = 3
)
UNION ALL
SELECT NAME, GRADE, HEIGHT, NO
FROM
(
SELECT NAME, GRADE, HEIGHT, RANK() OVER (ORDER BY HEIGHT DESC) "NO"
FROM STUDENT
WHERE GRADE = 4
);

SELECT NAME, GRADE, HEIGHT, RANK() OVER (PARTITION BY GRADE ORDER BY HEIGHT DESC)
FROM STUDENT;

-- JOIN : 테이블 합치기

-- 카티션 곱
-- 14건
SELECT *
FROM EMP;
--4건
SELECT *
FROM DEPT;
-- 14*4 : 56건 출력
SELECT *
FROM EMP, DEPT
ORDER BY ENAME;

-- EQUL JOIN = INNER JOIN
-- 오라클 조인 문법
SELECT E.ENAME, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

SELECT *
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO;

SELECT *
FROM EMP E, DEPT D 
WHERE E.DEPTNO (+) = D.DEPTNO;

SELECT S.NAME, P.NAME
FROM STUDENT S, PROFESSOR P
WHERE S.PROFNO = P.PROFNO;







-- DDL : 테이블 삭제(drop), 수정(alter), 생성(create) 에 사용
CREATE TABLE Reply(
    id NUMBER,
    content VARCHAR2(200) not null,
    boardId NUMBER,
    userId NUMBER,
    CONSTRAINT REPLY_PK PRIMARY KEY (id),
    CONSTRAINT REPLY_FK_BOARD_ID FOREIGN KEY (boardId) REFERENCES Board (id),
    CONSTRAINT REPLY_FK_USER_ID FOREIGN KEY (userId) REFERENCES Users (id)
);


-- 테이블 데이터 초기화
DELETE FROM BOARD;
DELETE FROM USERS;
-- 테이블 시퀀스 초기화
DROP SEQUENCE BOARD_SEQ;
DROP SEQUENCE USERS_SEQ;

-- BOARD, USERS 테이블 시퀀스, 데이터 생성
CREATE SEQUENCE users_seq
INCREMENT BY 1
START WITH 1;  

CREATE SEQUENCE board_seq
INCREMENT BY 1
START WITH 1; 

CREATE SEQUENCE reply_seq
INCREMENT BY 1
START WITH 1;

-- Users, Board, Reply
-- DML (데이터 조작어)
-- users 다 넣을꺼면 생략 가능(생략 안했을 때 순서 변경 할 수 있음)
INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'ssar', 'ssar@nate.com');

INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'love', 'love@nate.com');

INSERT INTO USERS(ID, USERNAME, EMAIL) 
VALUES(USERS_SEQ.nextval, 'cos', 'cos@nate.com');

commit;

select * from users;

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 1강', 'DDL이란?', 1);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 2강', 'DML이란?', 1);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 3강', 'DCL이란?', 2);

INSERT INTO BOARD(ID, TITLE, CONTENT, USERID) 
VALUES(BOARD_SEQ.nextval, '오라클 4강', 'DQL이란?', 1);

COMMIT;

select * from board;

INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES(REPLY_SEQ.nextval, '재미있어요.', 1, 1);

INSERT INTO REPLY(ID, CONTENT, BOARDID, USERID)
VALUES(REPLY_SEQ.nextval, '진짜 재미있어요.', 1, 2);

commit;

select * from reply;







-- 조인
SELECT *
FROM USERS U, BOARD B
WHERE U.ID = b.userid;

SELECT *
FROM USERS U, BOARD B
WHERE U.ID = b.userid(+);
--NULL값만 나오게 하기
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID(+)
AND R.ID IS NULL;

SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID(+)
MINUS
SELECT *
FROM USERS U, REPLY R
WHERE U.ID = R.USERID;


SELECT * FROM USERS;
SELECT * FROM BOARD;
SELECT * FROM REPLY;


SELECT ID, TITLE, USERID,
(SELECT COUNT(*) FROM REPLY WHERE BOARDID = B.ID) 댓글수
FROM BOARD B;

SELECT B.ID, B.TITLE, U.USERNAME, 
(SELECT COUNT(*) FROM REPLY WHERE BOARDID = B.ID) "댓글수"
FROM BOARD B, USERS U
WHERE B.USERID = U.ID;

SELECT B.ID, B.TITLE, U.USERNAME, COUNT(R.ID) 댓글수
FROM BOARD B, REPLY R, USERS U
WHERE B.ID = R.BOARDID(+) AND B.USERID = U.ID 
GROUP BY B.ID, B.TITLE, U.USERNAME;


--SELF JOIN
SELECT EMPNO, ENAME, JOB, MGR
FROM EMP E;

SELECT E1.EMPNO, E1.ENAME, E1.JOB, E1.MGR, E2.ENAME 상사
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO (+);

-- 오라클 조인
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;
-- ANSI 표준 JOIN : 조인할 때 ON 사용
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;
-- WHERE 생략 가능
SELECT E.EMPNO, E.ENAME, E.DEPTNO, D.DNAME
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO AND E.DEPTNO = 10;

-- 오라클 조인
SELECT *
FROM BOARD B, REPLY R
WHERE B.ID = R.BOARDID(+);
-- ANSI 표준 JOIN 
SELECT *
FROM BOARD B LEFT OUTER JOIN REPLY R
ON B.ID = R.BOARDID;

--FULL OUTER JOIN : 양쪽으로 다 뽑음. ANSI 표준에만 있음.
SELECT *
FROM BOARD B FULL OUTER JOIN REPLY R
ON B.ID = R.BOARDID;





-- 데이터 복제(숨기고 싶은 데이터 제외한)
CREATE TABLE STUDENT2
AS
SELECT STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO
FROM STUDENT;

SELECT *
FROM STUDENT2;

-- VIEW 생성
CREATE OR REPLACE VIEW STUDENT_VIEW
AS
SELECT STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO
FROM STUDENT;

SELECT *
FROM STUDENT;

SELECT * FROM STUDENT_VIEW;
-- 새로운 데이터 입력
INSERT INTO STUDENT_VIEW (STUDNO, NAME, ID, GRADE, HEIGHT, WEIGHT, DEPTNO1, DEPTNO2, PROFNO)
VALUES (9999,'홍길동','ssar', 4, 170, 70, 201, null, null);




-- 이하. 교재 296p 실습
INSERT INTO STUDENT_VIEW
VALUES(9998, '길동이', 'hong', 2, 165, 58, 102, null, null);

INSERT INTO STUDENT_VIEW (STUDNO, NAME, ID, GRADE)
VALUES (9997, '동길이', 'EE', 2); 

-- 음수 값 입력
CREATE TABLE t_minus
            ( no1 NUMBER,
              no2 NUMBER(3),
              no3 NUMBER(3,2));
      
INSERT INTO t_minus VALUES(1,1,1);
INSERT INTO t_minus VALUES(1.1,1.1,1.1);
INSERT INTO t_minus VALUES(-1.1,-1.1,-1.1);  

SELECT *
FROM t_minus;

-- 서브쿼리 사용하여 여러 행 입력
-- WHERE에 1=2 입력하여 데이터 입력 안되도록 함.
SELECT *
FROM PROFESSOR;
CREATE TABLE professor3
AS
SELECT *
FROM PROFESSOR
WHERE 1 = 2;

SELECT *
FROM PROFESSOR;

SELECT *
FROM PROFESSOR3;
-- ITAS : 서브쿼리를 사용하여 여러건의 데이터 한꺼번에 입력
-- 컬럼 갯수와 데이터형 동일해야 함.
INSERT INTO PROFESSOR3
SELECT *
FROM PROFESSOR;
-- WHERE을 사용하여 원하는 조건으로 출력
CREATE TABLE PROFESSOR4
AS
SELECT PROFNO, NAME, PAY
FROM PROFESSOR
WHERE 1 = 2;

SELECT *
FROM PROFESSOR4;

INSERT INTO PROFESSOR4
SELECT PROFNO, NAME, PAY
FROM PROFESSOR
WHERE PROFNO > 4000;

-- INSERT ALL을 이용하여 여러 테이블에 여러 행 입력
CREATE TABLE prof_3
            (PROFNO NUMBER,
             NAME VARCHAR2(25));
CREATE TABLE prof_4
            (PROFNO NUMBER,
             NAME VARCHAR2(25));

INSERT ALL
WHEN PROFNO BETWEEN 1000 AND 1999 THEN
    INTO prof_3 VALUES(PROFNO, NAME)    
WHEN PROFNO BETWEEN 2000 AND 2999 THEN
    INTO prof_4 VALUES(PROFNO, NAME)
SELECT PROFNO, NAME
FROM PROFESSOR;

SELECT *
FROM prof_3;

SELECT *
FROM prof_4;
-- 테이블 삭제
TRUNCATE TABLE prof_3;
TRUNCATE TABLE prof_4;
-- 테이블 동시 입력
INSERT ALL
    INTO prof_3 VALUES(PROFNO, NAME)
    INTO prof_4 VALUES(PROFNO, NAME)
SELECT PROFNO, NAME
FROM PROFESSOR
WHERE PROFNO BETWEEN 3000 AND 3999;

-- UPDATE(데이터 변경하기)
SELECT *
FROM PROFESSOR;

UPDATE PROFESSOR 
SET BONUS = 200
WHERE POSITION = '조교수';

UPDATE PROFESSOR 
SET PAY = PAY * 1.15
WHERE POSITION 
    = (SELECT POSITION 
       FROM PROFESSOR
       WHERE NAME = '박승곤')
AND PAY < 250;

-- DELETE(데이터 삭제하기)
-- 데이터 삭제 X, 남아있음 -> 테이블 크기 그대로임.
SELECT *
FROM DEPT2;

DELETE FROM DEPT2
WHERE DCODE >= 9000 AND DCODE <= 9999;

-- UPDATE 조인
SELECT * FROM EMP;
-- 단일 테이블
UPDATE EMP
SET SAL = (SAL + SAL*0.1)
WHERE JOB='CLERK';
-- 다른 테이블과 조인
UPDATE EMP E
SET SAL = (SAL + SAL*0.1)
WHERE EXISTS
    (
        SELECT 1 FROM DEPT D
        WHERE D.LOC = 'DALLAS' AND
              E.DEPTNO = D.DEPTNO
     )
;
--테이블 생성(부서발령이력)
CREATE TABLE DEPT_HIST
(
    EMPNO NUMBER(4),
    APPOINTSEQNO NUMBER(4),
    DEPTNO NUMBER(2),
    APPOINTDD DATE
);

SELECT * FROM DEPT_HIST;

INSERT INTO DEPT_HIST
SELECT EMPNO, 1 APPOINTSEQNO, 99 DEPTNO, SYSDATE APPOINTDD
FROM EMP
WHERE DEPTNO = 20;

INSERT INTO DEPT_HIST VALUES (9322, 1, 99, SYSDATE);
INSERT INTO DEPT_HIST VALUES (9322, 1, 99, SYSDATE);

SELECT E.EMPNO, E.DEPTNO TOBE_DEPTNO, D.DEPTNO ASIS_DEPTNO
FROM EMP E, DEPT_HIST D
WHERE E.EMPNO = D.EMPNO;

UPDATE DEPT_HIST d
SET D.DEPTNO = (
                 SELECT E.DEPTNO FROM EMP E
                 WHERE E.EMPNO = D.EMPNO
                );
                

-- 서브쿼리
-- 비교대상 SMITH 1명 
SELECT *
FROM EMP
WHERE SAL > 
    (SELECT SAL
     FROM EMP
     WHERE ENAME = 'SMITH');

SELECT SAL
FROM EMP
WHERE ENAME = 'SMITH';
-- 비교대상 MANAGER 여러 값 -> IN
SELECT *
FROM EMP
WHERE SAL IN 
    (SELECT SAL
     FROM EMP
     WHERE JOB = 'MANAGER');

SELECT ENAME, COMM
FROM EMP
WHERE COMM < ( SELECT COMM
               FROM EMP
               WHERE ENAME = 'WARD');

-- 단일행 서브쿼리
-- 441쪽 예제               
SELECT * FROM STUDENT;
SELECT * FROM DEPARTMENT;

SELECT S.NAME, D.DNAME
FROM STUDENT S, DEPARTMENT D
WHERE S.DEPTNO1 = D.DEPTNO 
AND S.DEPTNO1 = (SELECT DEPTNO1 FROM STUDENT WHERE NAME = '구유미');

SELECT * FROM PROFESSOR;
SELECT * FROM DEPARTMENT;

SELECT P.NAME, P.HIREDATE, D.DNAME  
FROM PROFESSOR P, DEPARTMENT D
WHERE P.DEPTNO = D.DEPTNO
AND HIREDATE > (SELECT HIREDATE
                FROM PROFESSOR
                WHERE NAME = '박승곤');

SELECT * FROM STUDENT;
-- 442p
SELECT NAME, WEIGHT 
FROM STUDENT 
WHERE WEIGHT > (SELECT FLOOR(AVG(WEIGHT))
                FROM STUDENT
                WHERE DEPTNO1 = 201);

-- 다중행 서브쿼리
-- 443p
SELECT EMPNO, NAME, DEPTNO
FROM EMP2
WHERE DEPTNO IN (SELECT DCODE
                 FROM DEPT2
                 WHERE AREA = '서울지사');

SELECT * 
FROM DEPT
WHERE EXISTS (SELECT DEPTNO
              FROM DEPT
              WHERE DEPTNO = &dno);
-- &dno : 값을 찾는 변수
SELECT * 
FROM DEPT
WHERE DEPTNO IN (SELECT DEPTNO
                 FROM DEPT
                 WHERE DEPTNO = &dno);
                  
SELECT * 
FROM DEPT
WHERE LOC IN (SELECT LOC
              FROM DEPT
              WHERE LOC = &dno);

SELECT * FROM EMP2;

SELECT NAME, POSITION, TO_CHAR(PAY,'$999,999,999') PAY
FROM EMP2
WHERE PAY > 
(
    SELECT MIN(PAY)
    FROM EMP2
    WHERE POSITION = '부장');

SELECT NAME, GRADE, WEIGHT
FROM STUDENT
WHERE WEIGHT <
(
    SELECT MIN(WEIGHT)
    FROM STUDENT
    WHERE GRADE = 2); 



